<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<style>

  body {
    font: 10px sans-serif;
  }

  .arc path {
    stroke: #fff;
  }

</style>
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css">
</head>
<body>

<div class="container-fluid">
  <div class="row">
    <div id="chart" class="col-sm-12"></div>
  </div>  
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>
<script>

var GOALS_CSV = 'data/2015-goals.csv';

var width = 100,
    height = 100,
    radius = Math.min(width, height) / 2;

// var color = d3.scale.category20();
// var color = d3.scale.ordinal()
//     .ranges(["#98abc5", "#8a89a6", "#7b6888", "#6b486b", "#a05d56", "#d0743c", "#ff8c00", '#b36200']);

var arc = d3.svg.arc()
    // the only difference with a regular piechart is that you set the innerRadius to 0
    .innerRadius(radius - 25) 
    .outerRadius(radius - 5);

var pie = d3.layout.pie()
    .sort(null)
    .value(function(d) { return d.total; });

var svg = d3.select("#chart")
    .append("svg")
    .attr("viewBox", "0 0 100 100")
    .attr("preserveAspectRatio", "xMinYMin meet")
  .append("g")
    .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")");

// the open segment
var openedSegment = {
  index: -1,
  origin: {
    path: null,
    label: null
  }
}

d3.csv(GOALS_CSV, function(error, data) {
  var finalTotal = d3.sum(data, function(d){ return d.total; });
  var totals = [];

  data.forEach(function(d) {
    d.total = +d.total;
    totals.push(d.total);
  });

  var color = d3.scale.linear()
  .domain([0, d3.max(totals)])
  .range(['#ffb832', '#c61c6f']);

  var path = svg.selectAll("path")
      .data(pie(data))
    .enter().append("path")
      .attr("transform", "translate(0, 0)")
      .style("fill", function(d) { return color(d.data.total); })
      .attr("d", arc)
      .attr('id', function(d, i) { return 'path-' + i; })
      .on('click', function(d, i) {
        var options = {
          centroid: arcCentroid(d),
          duration: 200
        };
        closeSegment(options);
        openSegment(i, options);
      });

  svg.selectAll('text')
    .data(pie(data))
    .enter().append("text")
      .attr("transform", function(d) { return "translate(" + arc.centroid(d) + ")"; })
      .attr("dy", ".35em")
      .attr('id', function(d, i) { return 'label-' + i; })
      .style("text-anchor", "middle")
      .style('fill', 'white')
      .style('font-size', '.12em')
      .text(function(d) { return d3.round(100 * d.data.total / finalTotal, 1) + '%'; })

});

/**
 * openedSegment open the segment 
 * @param  int    index     the index of the segment to open
 * @param  object centroid  the centroid of the arc
 * @param  int    duration  the duration of the transition in milliseconds
 */
function openSegment(index, options) {
  console.log(index);
  // if the segment is already opened
  if(index === openedSegment.index) {
    return;
  }
  console.log('openSegment');
  openedSegment.index = index;

  translate({ index: index, type: 'path' }, 'open', options)
  translate({ index: index, type: 'label' }, 'open', options)
}

function closeSegment(options) {
  if(openedSegment.index === -1) {
    return;
  }
  console.log('closeSegment');
  translate({ index: openedSegment.index, type: 'path' }, 'close', options)
  translate({ index: openedSegment.index, type: 'label' }, 'close', options)
}

function translate(element, mode, options) {
  var selection = '#' + element.type + '-' + element.index;
  var position = getPosition(selection);
  if(mode.localeCompare('open') === 0) {
    var translateValue = 'translate(' + (position.x + options.centroid.x / 20) + ', ' + (position.y + options.centroid.y / 20) + ')'
  } else {
    var translateValue = 'translate(' + openedSegment.origin[element.type].x + ', ' + openedSegment.origin[element.type].y + ')'
  }
  d3.select(selection)
    .transition()
    .duration(options.duration)
    .attr('transform', translateValue);

  openedSegment.origin[element.type] = position;
}

/**
 * getPosition get the translate x and y from the transform attribute of the selection
 * @param  string selection the input selection
 * @return object           the x and y coordinates as an object
 */
function getPosition(selection) {
  console.log(selection);
  var t = d3.select(selection).attr('transform').split(/[^\w-.]/gi);
  // console.log(JSON.stringify(t));
  // get rid of the empty strings in the array
  removeArrayItem(t, '');
  return { 
    x: parseFloat(t[1]), 
    y: parseFloat(t[2]) 
  };
}

/**
 * removeArrayItem remove the item by value
 * @param  array arr   the input array
 * @param  mixed value the input value to search for
 * @return bool        return true if the item has been removed     
 */
function removeArrayItem(arr, value) {
  var i = arr.indexOf(value);
  if(i != -1) {
    arr.splice(i, 1);
    return true;
  }
  return false;
}

/**
 * centroid get the centroid as an object
 * @param  object d the current data object
 * @return object   the centroid object | props: x and y
 */
function arcCentroid(d) {
  var c = arc.centroid(d);
  return { x: c[0], y: c[1] };
}

</script>
</body>
</html>